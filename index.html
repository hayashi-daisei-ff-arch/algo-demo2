<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>DFS/BFS 二分探索木 可視化</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<style>
  body { text-align:center; font-family:sans-serif; }
  label { display:block; margin-top:5px; }
  #resultDisplay { font-weight:bold; margin-top:10px; }
</style>
</head>
<body>
<h2>DFS/BFS 二分探索木 可視化（ノード15固定）</h2>

<label>探索対象ノード（0〜14）</label>
<input type="number" id="targetNode" value="7" min="0" max="14">

<label>探索アルゴリズム</label>
<select id="algorithm">
  <option value="DFS">深さ優先探索</option>
  <option value="BFS">幅優先探索</option>
</select>

<button onclick="runAlgorithm()">実行</button>

<p id="counter">操作数: 0</p>
<p id="resultDisplay"></p>

<script>
const NODE_COUNT = 15;
const SPEED = 3;

let nodes = [];
let edges = [];
let adj = [];
let steps = [];
let counter = 0;
let animationRunning = false;
let visited = [];
let foundNode = -1;

function setup(){
  createCanvas(900,400).parent(document.body);
  frameRate(SPEED*2);
  generateTree();
}

function draw(){
  if(animationRunning && counter<steps.length){
    let cur = steps[counter];
    if(cur!==null) visited[cur]=2;
    drawTree();
    if(cur!==null) visited[cur]=1;
    counter++;
    document.getElementById("counter").innerText="操作数: "+counter;
    if(counter>=steps.length){ animationRunning=false; showResult(); }
  }else{
    drawTree();
  }
}

function drawTree(){
  background(255);
  stroke(0);
  for(let e of edges){
    line(nodes[e[0]].x, nodes[e[0]].y, nodes[e[1]].x, nodes[e[1]].y);
  }
  for(let i=0;i<nodes.length;i++){
    let c=color(0,0,255);
    if(visited[i]===1) c=color(200);
    if(visited[i]===2) c=color(255,0,0);
    if(i===foundNode) c=color(255,255,0);
    fill(c);
    stroke(0);
    ellipse(nodes[i].x, nodes[i].y, 40,40);
    fill(0);
    noStroke();
    textAlign(CENTER,CENTER);
    text(i,nodes[i].x,nodes[i].y);
  }
}

function generateTree(){
  nodes=[];
  edges=[];
  adj=[];
  visited=[];
  for(let i=0;i<NODE_COUNT;i++){
    nodes.push({x:0,y:0});
    adj.push([]);
    visited.push(0);
  }
  for(let i=0;i<NODE_COUNT;i++){
    let left = 2*i+1;
    let right = 2*i+2;
    if(left<NODE_COUNT){ adj[i].push(left); adj[left].push(i); edges.push([i,left]); }
    if(right<NODE_COUNT){ adj[i].push(right); adj[right].push(i); edges.push([i,right]); }
  }
  layoutTree(0,0,50,width-50);
  steps=[];
  counter=0;
  animationRunning=false;
  foundNode=-1;
  drawTree();
}

function layoutTree(index, depth, xMin, xMax){
  let x=(xMin+xMax)/2;
  let y = 50 + depth*60;
  nodes[index].x = x;
  nodes[index].y = y;
  let left = 2*index+1;
  let right = 2*index+2;
  if(left<NODE_COUNT) layoutTree(left,depth+1,xMin,x);
  if(right<NODE_COUNT) layoutTree(right,depth+1,x,xMax);
}

function dfsBfs(start,target,algo){
  let n = NODE_COUNT;
  let visitedLocal = new Array(n).fill(false);
  if(algo==='DFS'){
    let stack=[start];
    while(stack.length>0){
      let u=stack.pop();
      if(visitedLocal[u]) continue;
      steps.push(u);
      visitedLocal[u]=true;
      if(u===target){foundNode=u; break;}
      for(let v of adj[u].slice().reverse()) if(!visitedLocal[v]) stack.push(v);
    }
  } else if(algo==='BFS'){
    let queue=[start];
    visitedLocal[start]=true;
    while(queue.length>0){
      let u=queue.shift();
      steps.push(u);
      if(u===target){foundNode=u; break;}
      for(let v of adj[u]){
        if(!visitedLocal[v]){
          visitedLocal[v]=true;
          queue.push(v);
        }
      }
    }
  }
}

function runAlgorithm(){
  let target=parseInt(document.getElementById("targetNode").value);
  let algo=document.getElementById("algorithm").value;
  steps=[];
  visited.fill(0);
  counter=0;
  animationRunning=true;
  foundNode=-1;
  dfsBfs(0,target,algo);
}

function showResult(){
  let target=parseInt(document.getElementById("targetNode").value);
  if(foundNode>=0){
    document.getElementById("resultDisplay").innerText="探索完了：ノード "+target+" を見つけました";
  }else{
    document.getElementById("resultDisplay").innerText="探索完了：ノード "+target+" は存在しません";
  }
}
</script>
</body>
</html>
